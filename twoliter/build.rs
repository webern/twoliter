use convert_case::{Case, Casing};
use flate2::write::GzEncoder;
use flate2::Compression;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::{env, fs};
use toml::Table;

const DATA_INPUT_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/embedded");
const MAKEFILE_RS_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/src/makefile.rs");

fn main() {
    println!("cargo:rerun-if-changed={}", DATA_INPUT_DIR);
    let data_input_dir = PathBuf::from(DATA_INPUT_DIR);
    let data_input_dir = data_input_dir.canonicalize().expect(&format!(
        "Unable to canonicalize '{}'",
        data_input_dir.display()
    ));

    // This is the directory that cargo creates for us so that we can pass things from the build
    // script to the main compilation phase.
    let out_dir =
        PathBuf::from(env::var("OUT_DIR").expect("The cargo variable 'OUT_DIR' is missing"));

    // This is where we will copy all of the things we want to add to our tarball. We will then
    // compress and tar this directory.
    let tools_dir = out_dir.join("tools");
    fs::create_dir_all(&tools_dir).expect(&format!(
        "Unable to create directory '{}'",
        tools_dir.display()
    ));

    // This is the filepath to the tarball we will create.
    let tar_path = out_dir.join("tools.tar.gz");

    // TODO - name this Makefile.toml when we have ported the Bottlerocket monorepo git history.
    let makefile_source = data_input_dir.join("Makefile.temp.toml");
    copy_file(makefile_source, tools_dir.join("Makefile.toml"));
    extract_makefile_dependency_graph(tools_dir.join("Makefile.toml"));

    // Create tarball
    let tar_gz =
        File::create(&tar_path).expect(&format!("Unable to create file '{}'", tar_path.display()));
    let enc = GzEncoder::new(&tar_gz, Compression::default());
    let mut tar = tar::Builder::new(enc);
    tar.append_dir_all("", &tools_dir).unwrap();
}

fn copy_file<P1, P2>(source: P1, dest: P2)
where
    P1: AsRef<Path>,
    P2: AsRef<Path>,
{
    let source = source.as_ref();
    let dest = dest.as_ref();
    fs::copy(source, dest).expect(&format!(
        "Unable to copy `{}' to '{}'",
        source.display(),
        dest.display()
    ));
}

fn extract_makefile_dependency_graph(makefile: impl AsRef<Path>) {
    let path = makefile.as_ref();
    let data = fs::read_to_string(&path).expect(&format!("Unable to read file {}", path.display()));
    let table = data.parse::<Table>().expect("Unable to parse makefile");
    drop(data);
    let tasks_table = table.get("tasks").unwrap().as_table().unwrap();
    // An list of (task_name, names_of_dependencies)
    let mut tasks: Vec<(&str, Vec<&str>)> = Vec::new();
    for (task_name, value) in tasks_table {
        let task_info = value.as_table().unwrap();
        // panic!("{:?}", task_info);
        let dependencies: Vec<&str> = match task_info.get("dependencies") {
            Some(value) => value
                .as_array()
                .unwrap()
                .into_iter()
                .map(|v| v.as_str().unwrap())
                .collect(),
            None => Vec::new(),
        };
        tasks.push((task_name, dependencies));
    }

    // Now we know all of the dependencies, convert this into static Rust constants.
    let out_path = PathBuf::from(MAKEFILE_RS_PATH);
    let mut f =
        File::create(&out_path).expect(&format!("Unable to create '{}'", out_path.display()));

    // TODO - rustfmt this mess somehow after generating it
    writeln!(f, "/*! This file is generated by build.rs !*/").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "use crate::common::MakefileTarget;").unwrap();
    writeln!(f, "use std::collections::HashMap;").unwrap();
    writeln!(f, "use lazy_static::lazy_static;").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "lazy_static! {{").unwrap();
    writeln!(
        f,
        "pub(crate) static ref TASK_DEPENDENCIES: HashMap<MakefileTarget, Vec<MakefileTarget>> ="
    )
    .unwrap();
    writeln!(f, "create_lookup();").unwrap();
    writeln!(f, "}}").unwrap();
    writeln!(f, "").unwrap();
    writeln!(
        f,
        "fn create_lookup() -> HashMap<MakefileTarget, Vec<MakefileTarget>> {{"
    )
    .unwrap();
    writeln!(f, "let mut map = HashMap::new();").unwrap();
    for (task, dependencies) in &tasks {
        writeln!(
            f,
            "map.insert(
            MakefileTarget::{},vec![",
            task.to_case(Case::Pascal)
        )
        .unwrap();
        for dependency in dependencies {
            writeln!(f, "MakefileTarget::{},", dependency.to_case(Case::Pascal)).unwrap();
        }
        writeln!(f, "]);").unwrap();
    }

    writeln!(f, "map").unwrap();

    writeln!(f, "}}").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "").unwrap();
}
//
// fn get_key<'a>(key: &str, table: &'a Table) -> &'a Table {
//     let value = table
//         .get(key)
//         .expect(&format!("The key '{}' was not found", key));
//     match value {
//         Value::Table(table) => table,
//         _ => panic!(
//             "Expected the '{}' key to be a table, but it was something else",
//             key
//         ),
//     }
// }

// fn get_key<'a>(key: &str, table: &'a Table) -> &'a Table {
//     let value = table
//         .get(key)
//         .expect(&format!("The key '{}' was not found", key));
// .to_
// }
